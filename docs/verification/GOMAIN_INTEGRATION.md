# Chatbox Service Integration with gomain

This document describes how the chatbox service integrates with the gomain service registry and provides instructions for deployment and testing.

## Overview

The chatbox service has been successfully integrated with gomain's service registry system. The integration follows gomain's standard service registration pattern, allowing the chatbox service to be dynamically loaded and managed alongside other services.

## Integration Steps Completed

### 1. Service Registry Entry

Added chatbox to gomain's `services.imports.txt`:

```
chatbox,github.com/real-rm/chatbox
```

This file is used by gomain's code generator to automatically create service registration code.

### 2. Dependency Management

Updated gomain's `go.mod` to include the chatbox dependency:

```go
require (
    github.com/real-rm/chatbox v0.0.0
    // ... other dependencies
)

replace github.com/real-rm/chatbox => ../chatbox
```

The `replace` directive allows local development by pointing to the chatbox repository in the parent directory.

### 3. Code Generation

Ran gomain's service generator to update `generated_services.go`:

```bash
go run ./cmd/genservices -in services.imports.txt -out generated_services.go
```

This generated the following registration code:

```go
// Code generated by genservices; DO NOT EDIT.
package main

import (
    gopromptadmin "github.com/real-rm/gopromptadmin"
    chatbox "github.com/real-rm/chatbox"
)

func init() {
    overrideRegistry = map[string]serviceRegistrar{
        "gopromptadmin": gopromptadmin.Register,
        "chatbox": chatbox.Register,
    }
}
```

## Service Registration

The chatbox service implements the standard gomain service registration interface:

```go
func Register(
    r *gin.Engine,
    config *goconfig.ConfigAccessor,
    logger *golog.Logger,
    mongo *gomongo.Mongo,
) error
```

When gomain starts, it:
1. Loads configuration from `config.toml`
2. Initializes logger and MongoDB connection
3. Creates a Gin router
4. Calls `chatbox.Register()` with shared resources
5. Starts the HTTP server

## Registered Endpoints

The chatbox service registers the following endpoints:

### WebSocket Endpoint
- `GET /chat/ws` - WebSocket endpoint for real-time chat communication
  - Requires JWT token in query parameter or Authorization header
  - Upgrades HTTP connection to WebSocket
  - Handles bidirectional message exchange

### Admin HTTP Endpoints
All admin endpoints require JWT authentication with admin role:

- `GET /chat/admin/sessions` - List all sessions with filtering and sorting
- `GET /chat/admin/metrics` - Get session metrics and statistics
- `POST /chat/admin/takeover/:sessionID` - Initiate admin session takeover

### Health Check Endpoints
- `GET /chat/healthz` - Liveness probe for Kubernetes
- `GET /chat/readyz` - Readiness probe for Kubernetes (checks MongoDB connection)

## Configuration

Add the following configuration to gomain's `config.toml`:

```toml
[app]
port = 8080
shutdown_timeout_s = 5

[chatbox]
jwt_secret = "your-jwt-secret-key"
reconnect_timeout = "15m"

[chatbox.websocket]
read_buffer_size = 1024
write_buffer_size = 1024
pong_wait = "60s"
ping_period = "54s"
write_wait = "10s"

# LLM Providers
[[chatbox.llm.providers]]
id = "openai-gpt4"
name = "GPT-4"
type = "openai"
endpoint = "https://api.openai.com/v1"
apiKey = "sk-..."
model = "gpt-4"

[[chatbox.llm.providers]]
id = "anthropic-claude"
name = "Claude"
type = "anthropic"
endpoint = "https://api.anthropic.com/v1"
apiKey = "sk-ant-..."
model = "claude-3-opus"

# MongoDB configuration
[dbs]
verbose = 1
slowThreshold = 2

[dbs.chat]
uri = "mongodb://localhost:27017/chat"

# S3 configuration for file uploads
[connection_sources]
  [[connection_sources.s3_providers]]
    name = "aws-chat-storage"
    endpoint = "s3.us-east-1.amazonaws.com"
    key = "YOUR_AWS_ACCESS_KEY"
    pass = "YOUR_AWS_SECRET_KEY"
    region = "us-east-1"

# Upload configuration
[userupload]
site = "CHAT"
  [[userupload.types]]
    entryName = "uploads"
    prefix = "/chat-files"
    tmpPath = "./temp/uploads"
    maxSize = "100MB"
    storage = [
      { type = "s3", target = "aws-chat-storage", bucket = "chat-files" }
    ]

# Mail configuration
[mail]
defaultFromName = "Chat Support"
replyToEmail = "support@example.com"
adminEmail = "admin@example.com"

[[mail.engines.ses]]
name = "ses-primary"
accessKeyId = "AKIAXXXXXXXX"
secretAccessKey = "xxxxxxxx"
region = "us-east-1"
from = "noreply@example.com"

# Logging configuration
[golog]
dir = "logs"
level = "info"
standard_output = true
info = "info.log"
warn = "warn.log"
error = "error.log"
verbose = "verbose.log"
```

## Service Lifecycle

### Initialization
1. gomain loads configuration from `config.toml`
2. gomain initializes logger with structured logging
3. gomain initializes MongoDB connection with connection pooling
4. gomain creates Gin router
5. gomain calls `chatbox.Register()` with shared resources
6. chatbox service initializes all internal components:
   - JWT validator for authentication
   - Session manager for connection tracking
   - Storage service for MongoDB persistence
   - Upload service for S3 file handling
   - LLM service for AI backend integration
   - Notification service for email/SMS alerts
   - Message router for routing messages
   - WebSocket handler for real-time communication
7. chatbox service registers all HTTP and WebSocket routes
8. gomain starts HTTP server on configured port

### Runtime
- gomain handles incoming HTTP requests and routes them to registered services
- chatbox service handles WebSocket connections and message routing
- All services share the same logger, config, and MongoDB connection
- Services can communicate through shared resources

### Graceful Shutdown
1. gomain receives SIGTERM or SIGINT signal
2. gomain logs shutdown signal and notifies administrators
3. gomain calls `server.Shutdown()` with configured timeout (default 5 seconds)
4. HTTP server stops accepting new connections
5. HTTP server waits for active requests to complete (up to timeout)
6. WebSocket connections are closed gracefully:
   - Active message processing completes
   - Session state is persisted to MongoDB
   - Connections send close frames to clients
   - Connection resources are cleaned up
7. MongoDB connections are closed
8. Logger is flushed and closed
9. gomain exits with status code 0

The graceful shutdown ensures:
- No data loss from in-flight messages
- All session state is persisted
- Clients receive proper connection close notifications
- Resources are properly cleaned up

## Service Enablement

To enable the chatbox service, use one of the following methods:

### Method 1: Environment Variable (All Services)
```bash
export ENABLE_SERVICES=all
./gomain
```

### Method 2: Environment Variable (Specific Services)
```bash
export ENABLE_SERVICES=chatbox,gopromptadmin
./gomain
```

### Method 3: Services File
Create a `services.txt` file:
```
chatbox
gopromptadmin
```

Then run:
```bash
export SERVICES_FILE=services.txt
./gomain
```

## Testing Service Registration

### 1. Build gomain with chatbox
```bash
cd /Users/fx/work/gomain
go mod tidy
go build -o gomain
```

### 2. Run gomain with chatbox enabled
```bash
export ENABLE_SERVICES=chatbox
./gomain
```

### 3. Verify service registration
Check the logs for:
```
INFO Service registered name=chatbox
INFO Chatbox service registered successfully websocket_endpoint=/chat/ws admin_endpoints=/chat/admin/* health_endpoints=/chat/healthz, /chat/readyz
```

### 4. Test health check endpoints
```bash
# Liveness probe
curl http://localhost:8080/chat/healthz

# Readiness probe
curl http://localhost:8080/chat/readyz
```

Expected responses:
```json
{"status":"healthy"}
{"status":"ready"}
```

### 5. Test WebSocket connection
```bash
# Install wscat if not already installed
npm install -g wscat

# Connect to WebSocket endpoint with JWT token
wscat -c "ws://localhost:8080/chat/ws?token=YOUR_JWT_TOKEN"
```

### 6. Test graceful shutdown
```bash
# Start gomain in one terminal
./gomain

# In another terminal, send SIGTERM
pkill -TERM gomain

# Check logs for graceful shutdown messages
tail -f logs/info.log
```

Expected log output:
```
INFO Received shutdown signal signal=terminated
INFO Shutting down server...
INFO Server exited gracefully
```

## Kubernetes Deployment

The chatbox service is designed to work seamlessly with Kubernetes:

### Health Probes
```yaml
livenessProbe:
  httpGet:
    path: /chat/healthz
    port: 8080
  initialDelaySeconds: 10
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /chat/readyz
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 5
```

### Graceful Shutdown
```yaml
lifecycle:
  preStop:
    exec:
      command: ["/bin/sh", "-c", "sleep 5"]
terminationGracePeriodSeconds: 30
```

### Service Configuration
```yaml
apiVersion: v1
kind: Service
metadata:
  name: gomain
spec:
  selector:
    app: gomain
  ports:
    - name: http
      port: 80
      targetPort: 8080
  type: LoadBalancer
```

## Troubleshooting

### Service Not Registered
**Problem**: Chatbox service not appearing in logs

**Solution**:
1. Check `ENABLE_SERVICES` environment variable
2. Verify `services.txt` file exists and contains "chatbox"
3. Check `generated_services.go` includes chatbox import

### Configuration Errors
**Problem**: Service fails to start with config errors

**Solution**:
1. Verify `config.toml` contains all required chatbox configuration
2. Check JWT secret is set: `chatbox.jwt_secret`
3. Verify MongoDB URI is correct: `dbs.chat.uri`
4. Check LLM provider configuration is valid

### MongoDB Connection Errors
**Problem**: Readiness probe fails with MongoDB errors

**Solution**:
1. Verify MongoDB is running and accessible
2. Check MongoDB URI in configuration
3. Verify network connectivity to MongoDB
4. Check MongoDB authentication credentials

### WebSocket Connection Errors
**Problem**: WebSocket connections fail to establish

**Solution**:
1. Verify JWT token is valid and not expired
2. Check JWT secret matches between token issuer and chatbox
3. Verify nginx reverse proxy WebSocket configuration
4. Check firewall rules allow WebSocket connections

## Next Steps

After successful integration, the following tasks remain:

1. **Frontend Development**: Implement HTML/JavaScript chat client
2. **Admin UI**: Create administrative interface for monitoring
3. **Integration Testing**: Write end-to-end tests with real services
4. **Performance Testing**: Load test with concurrent connections
5. **Documentation**: Create user guides and API documentation
6. **Deployment**: Deploy to production Kubernetes cluster

## References

- [gomain Repository](https://github.com/real-rm/gomain)
- [chatbox Repository](https://github.com/real-rm/chatbox)
- [Chatbox Design Document](.kiro/specs/chat-application-websocket/design.md)
- [Chatbox Requirements](.kiro/specs/chat-application-websocket/requirements.md)
- [Service Registration Documentation](REGISTER.md)
